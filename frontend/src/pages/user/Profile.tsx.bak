import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import api from '../../api/axios';
import { 
  Container, 
  Typography, 
  Avatar, 
  Button, 
  TextField, 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions, 
  Snackbar, 
  Alert, 
  IconButton,
  InputAdornment,
  Box,
  Card,
  CardContent,
  Grid,
  List,
  ListItemButton,
  ListItemText,
  Collapse,
  CircularProgress,
  Chip,
  Paper
} from '@mui/material';
import {
  LockReset as LockResetIcon,
  Feedback as FeedbackIcon,
  Home as HomeIcon,
  Logout as LogoutIcon,
  Visibility,
  VisibilityOff,
  ExpandMore,
  ExpandLess,
  Article as ArticleIcon,
  Assignment as AssignmentIcon,
  WarningAmber as WarningAmberIcon,
  Verified as VerifiedIcon,
  Timeline as TimelineIcon,
  RateReview as RateReviewIcon
} from '@mui/icons-material';

// Types and Interfaces
type Severity = 'success' | 'error' | 'warning' | 'info';

interface User {
  id: string;
  email: string;
  full_name: string;
  created_at: string;
  updated_at: string;
  is_active: boolean;
  is_superuser: boolean;
  is_verified: boolean;
}

interface Prediction {
  id: string;
  title: string;
  content: string;
  output_data: {
    is_fake?: boolean;
    confidence?: number;
    prediction?: string;
    [key: string]: any;
  };
  created_at: string;
  updated_at: string;
  user_id: string;
  feedback?: string;
  feedback_created_at?: string;
  model_name?: string;
  confidence?: number;
  status?: string;
}

interface FeedbackForm {
  content: string;
  predictionId?: string;
}

interface PasswordForm {
  oldPassword: string;
  newPassword: string;
  confirmPassword: string;
}

interface SnackbarState {
  open: boolean;
  message: string;
  severity: Severity;
}

interface UserStatistics {
  totalPredictions: number;
  fakePredictions: number;
  realPredictions: number;
  predictionAccuracy: number;
  feedbackCount: number;
}

interface ApiResponse<T = any> {
  data: T;
  message?: string;
  success: boolean;
  severity?: Severity;
}

interface StatCardProps {
  title: string;
  value: string | number;
  icon: React.ReactNode;
  color: string;
}

// StatCard Component
const StatCard: React.FC<StatCardProps> = ({ title, value, icon, color }) => (
  <Card sx={{ height: '100%' }}>
    <CardContent>
      <Box display="flex" alignItems="center" mb={1}>
        <Box color={color} mr={1}>
          {icon}
        </Box>
        <Typography variant="subtitle2" color="textSecondary">
          {title}
        </Typography>
      </Box>
      <Typography variant="h6">
        {value}
      </Typography>
    </CardContent>
  </Card>
);

// Format date to a readable format
const formatDate = (dateString?: string | Date): string => {
  if (!dateString) return 'N/A';
  
  const date = new Date(dateString);
  if (isNaN(date.getTime())) return 'Invalid date';
  
  return date.toLocaleDateString('tr-TR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
};

// Helper function to check if a prediction is fake
const isFakePrediction = (prediction: Prediction): boolean => {
  if (!prediction.output_data) return false;
  
  // Handle different possible structures of output_data
  if (typeof prediction.output_data === 'object') {
    // Handle direct boolean value
    if (typeof prediction.output_data.is_fake === 'boolean') {
      return prediction.output_data.is_fake;
    }
    
    // Handle string values
    if (prediction.output_data.prediction) {
      return String(prediction.output_data.prediction).toLowerCase().includes('fake');
    }
    
    // Handle numeric values (0 for fake, 1 for real)
    if (typeof prediction.output_data.prediction === 'number') {
      return prediction.output_data.prediction === 0;
    }
  }
  
  // Handle string output
  if (typeof prediction.output_data === 'string') {
    return prediction.output_data.toLowerCase().includes('fake');
  }
  
  return false;
};

const Profile: React.FC = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  
  // State for dialogs
  const [passwordDialogOpen, setPasswordDialogOpen] = useState<boolean>(false);
  const [feedbackDialogOpen, setFeedbackDialogOpen] = useState<boolean>(false);
  const [expandedPrediction, setExpandedPrediction] = useState<string | null>(null);
  
  // Password visibility state
  const [showPassword, setShowPassword] = useState({
    old: false,
    new: false,
    confirm: false
  });
  
  // Form states
  const [passwordForm, setPasswordForm] = useState<PasswordForm>({
    oldPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  const [feedbackForm, setFeedbackForm] = useState<FeedbackForm>({
    content: '',
    predictionId: undefined
  });
  
  // Snackbar state
  const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: '',
    severity: 'info'
  });
  
  // Statistics state
  const [statistics, setStatistics] = useState<UserStatistics>({
    totalPredictions: 0,
    fakePredictions: 0,
    realPredictions: 0,
    predictionAccuracy: 0,
    feedbackCount: 0
  });

  // Fetch user data
  const { data: user, isLoading: isUserLoading } = useQuery<User>({
    queryKey: ['userProfile'],
    queryFn: async () => {
      const response = await api.get<ApiResponse<User>>('/profile');
      return response.data.data;
    },
    onError: (error) => {
      console.error('Error fetching user profile:', error);
      setSnackbar({
        open: true,
        message: 'Profil bilgileri yüklenirken bir hata oluştu',
        severity: 'error'
      });
    }
  });

  // Fetch user predictions
  const { data: predictions = [], isLoading: isPredictionsLoading } = useQuery<Prediction[]>({
    queryKey: ['userPredictions'],
    queryFn: async () => {
      const response = await api.get<ApiResponse<Prediction[]>>('/my-predictions');
      return response.data.data;
    },
    onError: (error) => {
      console.error('Error fetching predictions:', error);
      setSnackbar({
        open: true,
        message: 'Tahmin geçmişi yüklenirken bir hata oluştu',
        severity: 'error'
      });
    },
    onSuccess: (data) => {
      // Calculate statistics when predictions are loaded
      const total = data.length;
      const fakeCount = data.filter(pred => isFakePrediction(pred)).length;
      const realCount = total - fakeCount;
      const accuracy = total > 0 ? Math.round((fakeCount / total) * 100) : 0;
      
      setStatistics({
        totalPredictions: total,
        fakePredictions: fakeCount,
        realPredictions: realCount,
        predictionAccuracy: accuracy,
        feedbackCount: data.filter(pred => pred.feedback).length
      });
    }
  });

  // Handle password change
  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setPasswordForm(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // Handle feedback form changes
  const handleFeedbackChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFeedbackForm(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // Toggle password visibility
  const handleClickShowPassword = (field: keyof typeof showPassword) => {
    setShowPassword(prev => ({
      ...prev,
      [field]: !prev[field]
    }));
  };

  // Toggle prediction expansion
  const handleExpandPrediction = (predictionId: string) => {
    setExpandedPrediction(prev => 
      prev === predictionId ? null : predictionId
    );
  };

  // Handle password form submission
  const handleSubmitPasswordChange = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (passwordForm.newPassword !== passwordForm.confirmPassword) {
      setSnackbar({
        open: true,
        message: 'Yeni şifreler eşleşmiyor',
        severity: 'error'
      });
      return;
    }
    
    try {
      await api.post('/update-password', {
        old_password: passwordForm.oldPassword,
        new_password: passwordForm.newPassword
      });
      
      setSnackbar({
        open: true,
        message: 'Şifre başarıyla güncellendi',
        severity: 'success'
      });
      
      setPasswordDialogOpen(false);
      setPasswordForm({
        oldPassword: '',
        newPassword: '',
        confirmPassword: ''
      });
    } catch (error: any) {
      console.error('Error updating password:', error);
      setSnackbar({
        open: true,
        message: error.response?.data?.message || 'Şifre güncellenirken bir hata oluştu',
        severity: 'error'
      });
    }
  };

  // Handle feedback submission
  const handleSubmitFeedback = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!feedbackForm.predictionId || !feedbackForm.content.trim()) {
      setSnackbar({
        open: true,
        message: 'Lütfen geri bildirim içeriği giriniz',
        severity: 'warning'
      });
      return;
    }
    
    try {
      await api.post('/submit-feedback', {
        prediction_id: feedbackForm.predictionId,
        content: feedbackForm.content
      });
      
      // Invalidate and refetch predictions to get updated feedback
      await queryClient.invalidateQueries({ queryKey: ['userPredictions'] });
      
      setSnackbar({
        open: true,
        message: 'Geri bildiriminiz için teşekkürler!',
        severity: 'success'
      });
      
      setFeedbackDialogOpen(false);
      setFeedbackForm({
        content: '',
        predictionId: undefined
      });
    } catch (error: any) {
      console.error('Error submitting feedback:', error);
      setSnackbar({
        open: true,
        message: error.response?.data?.message || 'Geri bildirim gönderilirken bir hata oluştu',
        severity: 'error'
      });
    }
  };

  // Handle logout
  const handleLogout = async () => {
    try {
      await api.post('/sign-out');
      // Clear any cached data
      queryClient.clear();
      // Redirect to login
      navigate('/login');
    } catch (error) {
      console.error('Error during logout:', error);
      // Still redirect even if logout API fails
      navigate('/login');
    }
  };

  // Handle snackbar close
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };

  // Loading state
  if (isUserLoading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="60vh">
        <CircularProgress />
      </Box>
    );
  }


  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      {/* Password Change Dialog */}
      <Dialog open={passwordDialogOpen} onClose={() => setPasswordDialogOpen(false)}>
        <DialogTitle>Şifre Değiştir</DialogTitle>
        <form onSubmit={handleSubmitPasswordChange}>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              name="oldPassword"
              label="Mevcut Şifre"
              type={showPassword.old ? 'text' : 'password'}
              fullWidth
              variant="outlined"
              value={passwordForm.oldPassword}
              onChange={handlePasswordChange}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      onClick={() => handleClickShowPassword('old')}
                      edge="end"
                    >
                      {showPassword.old ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="dense"
              name="newPassword"
              label="Yeni Şifre"
              type={showPassword.new ? 'text' : 'password'}
              fullWidth
              variant="outlined"
              value={passwordForm.newPassword}
              onChange={handlePasswordChange}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      onClick={() => handleClickShowPassword('new')}
                      edge="end"
                    >
                      {showPassword.new ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="dense"
              name="confirmPassword"
              label="Yeni Şifre (Tekrar)"
              type={showPassword.confirm ? 'text' : 'password'}
              fullWidth
              variant="outlined"
              value={passwordForm.confirmPassword}
              onChange={handlePasswordChange}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      onClick={() => handleClickShowPassword('confirm')}
                      edge="end"
                    >
                      {showPassword.confirm ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setPasswordDialogOpen(false)}>İptal</Button>
            <Button type="submit" color="primary">Kaydet</Button>
          </DialogActions>
        </form>
      </Dialog>

      {/* Feedback Dialog */}
      <Dialog 
        open={feedbackDialogOpen} 
        onClose={() => setFeedbackDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>Geri Bildirim Gönder</DialogTitle>
        <form onSubmit={handleSubmitFeedback}>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              name="content"
              label="Geri Bildiriminiz"
              type="text"
              fullWidth
              multiline
              rows={4}
              variant="outlined"
              value={feedbackForm.content}
              onChange={handleFeedbackChange}
              required
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setFeedbackDialogOpen(false)}>İptal</Button>
            <Button type="submit" color="primary">Gönder</Button>
          </DialogActions>
        </form>
      </Dialog>

      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert 
          onClose={handleCloseSnackbar} 
          severity={snackbar.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>

      {/* User Profile Header */}
      <Grid container spacing={3} sx={{ mb: 4 }}>
        <Grid item xs={12} md={4}>
          <Card sx={{ height: '100%' }}>
            <CardContent sx={{ textAlign: 'center' }}>
              <Avatar 
                sx={{ 
                  width: 100, 
                  height: 100, 
                  margin: '0 auto 16px',
                  bgcolor: 'primary.main',
                  fontSize: '2.5rem'
                }}
              >
                {user?.full_name?.charAt(0) || 'U'}
              </Avatar>
              <Typography variant="h5" gutterBottom>
                {user?.full_name || 'Kullanıcı'}
              </Typography>
              <Typography variant="body2" color="text.secondary" gutterBottom>
                {user?.email}
              </Typography>
              <Typography variant="body2" color="text.secondary" gutterBottom>
                Üyelik Tarihi: {user?.created_at ? formatDate(user.created_at) : 'Bilinmiyor'}
              </Typography>
              <Box mt={2} display="flex" flexDirection="column" gap={1}>
                <Button 
                  variant="outlined" 
                  startIcon={<LockResetIcon />}
                  onClick={() => setPasswordDialogOpen(true)}
                >
                  Şifre Değiştir
                </Button>
                <Button 
                  variant="outlined" 
                  startIcon={<HomeIcon />}
                  onClick={() => navigate('/')}
                  sx={{ mt: 1 }}
                >
                  Ana Sayfaya Dön
                </Button>
                <Button 
                  variant="outlined" 
                  color="error"
                  startIcon={<LogoutIcon />}
                  onClick={handleLogout}
                  sx={{ mt: 1 }}
                >
                  Çıkış Yap
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Grid>
        
        {/* Statistics Cards */}
        <Grid item xs={12} md={8}>
          <Grid container spacing={2}>
            <Grid item xs={12} sm={6} md={6}>
              <StatCard
                title="Toplam Tahmin"
                value={statistics.totalPredictions}
                icon={<ArticleIcon />}
                color="primary.main"
              />
            </Grid>
            <Grid item xs={12} sm={6} md={6}>
              <StatCard
                title="Sahte Haber"
                value={statistics.fakePredictions}
                icon={<WarningAmberIcon />}
                color="error.main"
              />
            </Grid>
            <Grid item xs={12} sm={6} md={6}>
              <StatCard
                title="Gerçek Haber"
                value={statistics.realPredictions}
                icon={<VerifiedIcon />}
                color="success.main"
              />
            </Grid>
            <Grid item xs={12} sm={6} md={6}>
              <StatCard
                title="Doğruluk Oranı"
                value={`%${statistics.predictionAccuracy}`}
                icon={<TimelineIcon />}
                color="info.main"
              />
            </Grid>
          </Grid>
        </Grid>
      </Grid>

      {/* Predictions List */}
      <Grid item xs={12} md={8}>
        <Card>
          <CardContent>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
              <Typography variant="h6" gutterBottom>
                Tahmin Geçmişim
              </Typography>
              {isPredictionsLoading && <CircularProgress size={24} />}
            </Box>
            
            {predictions.length === 0 ? (
              <Box textAlign="center" py={4}>
                <AssignmentIcon color="action" style={{ fontSize: 48, opacity: 0.5 }} />
                <Typography variant="subtitle1" color="textSecondary" gutterBottom>
                  Henüz tahmin geçmişiniz bulunmuyor
                </Typography>
                <Button 
                  variant="contained" 
                  color="primary" 
                  onClick={() => navigate('/')}
                  startIcon={<ArticleIcon />}
                >
                  Hemen Tahmin Yap
                </Button>
              </Box>
            ) : (
              <List>
                {predictions.map((prediction) => {
                  const isFake = isFakePrediction(prediction);
                  const isExpanded = expandedPrediction === prediction.id;
                  
                  return (
                    <Paper 
                      key={prediction.id} 
                      elevation={2} 
                      sx={{ 
                        mb: 2, 
                        overflow: 'hidden',
                        borderLeft: 4,
                        borderColor: isFake ? 'error.main' : 'success.main'
                      }}
                    >
                      <ListItemButton 
                        onClick={() => handleExpandPrediction(prediction.id)}
                        sx={{ 
                          bgcolor: isExpanded ? 'action.hover' : 'background.paper',
                          '&:hover': {
                            bgcolor: 'action.hover'
                          }
                        }}
                      >
                        <Box sx={{ flexGrow: 1 }}>
                          <Box display="flex" alignItems="center" mb={0.5}>
                            <Chip 
                              label={isFake ? 'Sahte Haber' : 'Gerçek Haber'} 
                              color={isFake ? 'error' : 'success'}
                              size="small"
                              sx={{ mr: 1 }}
                            />
                            <Typography variant="subtitle2" color="text.secondary">
                              {formatDate(prediction.created_at)}
                            </Typography>
                          </Box>
                          <Typography variant="subtitle1" noWrap>
                            {prediction.title || 'Başlıksız Tahmin'}
                          </Typography>
                        </Box>
                        {isExpanded ? <ExpandLess /> : <ExpandMore />}
                      </ListItemButton>
                      
                      <Collapse in={isExpanded} timeout="auto" unmountOnExit>
                        <Box p={2} bgcolor="background.paper">
                          <Typography variant="body2" color="text.secondary" paragraph>
                            <strong>İçerik:</strong> {prediction.content || 'İçerik yok'}
                          </Typography>
                          <Typography variant="body2" color="text.secondary" paragraph>
                            <strong>Model:</strong> {prediction.model_name || 'Bilinmiyor'}
                          </Typography>
                          <Typography variant="body2" color="text.secondary" paragraph>
                            <strong>Oluşturulma Tarihi:</strong> {formatDate(prediction.created_at)}
                          </Typography>
                          
                          {prediction.feedback ? (
                            <Box mt={2} p={2} bgcolor="action.hover" borderRadius={1}>
                              <Box display="flex" alignItems="center" mb={1}>
                                <RateReviewIcon color="primary" fontSize="small" sx={{ mr: 1 }} />
                                <Typography variant="subtitle2">Geri Bildiriminiz</Typography>
                              </Box>
                              <Typography variant="body2">{prediction.feedback}</Typography>
                              <Typography variant="caption" color="text.secondary" display="block" mt={1}>
                                {formatDate(prediction.feedback_created_at)}
                              </Typography>
                            </Box>
                          ) : (
                            <Button
                              variant="outlined"
                              size="small"
                              startIcon={<FeedbackIcon />}
                              onClick={() => {
                                setFeedbackForm({
                                  content: '',
                                  predictionId: prediction.id
                                });
                                setFeedbackDialogOpen(true);
                              }}
                              sx={{ mt: 1 }}
                            >
                              Geri Bildirim Gönder
                            </Button>
                          )}
                        </Box>
                      </Collapse>
                    </Paper>
                  );
                })}
              </List>
            )}
          </CardContent>
        </Card>
      </Grid>
    </Container>
  );
};

export default Profile;

// Types and Interfaces
type Severity = 'success' | 'error' | 'warning' | 'info';

interface User {
  id: string;
  email: string;
  full_name: string;
  created_at: string;
  updated_at: string;
  is_active: boolean;
  is_superuser: boolean;
  is_verified: boolean;
}

interface Prediction {
  id: string;
  title: string;
  content: string;
  output_data: {
    is_fake?: boolean;
    confidence?: number;
    prediction?: string;
    [key: string]: any;
  };
  created_at: string;
  updated_at: string;
  user_id: string;
  feedback?: string;
  feedback_created_at?: string;
  model_name?: string;
  confidence?: number;
  status?: string;
}

interface FeedbackForm {
  content: string;
  predictionId?: string;
}

interface PasswordForm {
  oldPassword: string;
  newPassword: string;
  confirmPassword: string;
}

interface SnackbarState {
  open: boolean;
  message: string;
  severity: Severity;
}

interface UserStatistics {
  totalPredictions: number;
  fakePredictions: number;
  realPredictions: number;
  predictionAccuracy: number;
  feedbackCount: number;
  lastPredictionDate?: string;
  mostCommonCategory?: string;
}

interface ApiResponse<T = any> {
  data: T;
  message?: string;
  success: boolean;
  severity?: Severity;
}

interface StatCardProps {
  title: string;
  value: string | number;
  icon: React.ReactNode;
  color: string;
}

// StatCard Component
const StatCard: React.FC<StatCardProps> = ({ title, value, icon, color }) => (
  <Card sx={{ height: '100%' }}>
    <CardContent>
      <Box display="flex" alignItems="center" mb={1}>
        <Box color={color} mr={1}>
          {icon}
        </Box>
        <Typography variant="subtitle2" color="textSecondary">
          {title}
        </Typography>
      </Box>
      <Typography variant="h6">
        {value}
      </Typography>
    </CardContent>
  </Card>
);

// Format date to a readable format
const formatDate = (dateString?: string | Date) => {
  if (!dateString) return 'N/A';
  
  const date = new Date(dateString);
  if (isNaN(date.getTime())) return 'Invalid date';
  
  return new Intl.DateTimeFormat('tr-TR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  }).format(date);
};

// Helper function to check if a prediction is fake
const isFakePrediction = (prediction: Prediction): boolean => {
  if (!prediction) return false;
  
  // Handle string output (from direct API response)
  if (typeof prediction.output_data === 'string') {
    try {
      const parsed = JSON.parse(prediction.output_data);
      return parsed?.label?.toLowerCase().includes('fake') || parsed?.result === '0';
    } catch {
      return prediction.output_data.toLowerCase().includes('fake');
    }
  }
  
  // Handle object output (from direct API response)
  if (typeof prediction.output_data === 'object' && prediction.output_data !== null) {
    const output = Array.isArray(prediction.output_data) ? prediction.output_data[0] : prediction.output_data;
    return output?.label?.toLowerCase().includes('fake') || output?.result === '0';
  }
  
  // Fallback to checking the status field if it exists
  return prediction.status?.toLowerCase().includes('fake') || false;
};

// StatCard Component
const StatCard: React.FC<StatCardProps> = ({ title, value, icon, color }) => (
  <Card sx={{ height: '100%' }}>
    <CardContent>
      <Box display="flex" alignItems="center" mb={1}>
        <Box color={color} mr={1}>
          {icon}
        </Box>
        <Typography variant="subtitle2" color="textSecondary">
          {title}
        </Typography>
      </Box>
      <Typography variant="h6">
        {value}
      </Typography>
    </CardContent>
  </Card>
);

// Main Profile Component
const Profile: React.FC = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  
  // State for dialogs
  const [passwordDialogOpen, setPasswordDialogOpen] = useState<boolean>(false);
  const [feedbackDialogOpen, setFeedbackDialogOpen] = useState<boolean>(false);
  const [expandedPrediction, setExpandedPrediction] = useState<string | null>(null);
  
  // Password visibility state
  const [showPassword, setShowPassword] = useState({
    old: false,
    new: false,
    confirm: false
  });
  
  // Form states
  const [passwordForm, setPasswordForm] = useState<PasswordForm>({
    oldPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  const [feedbackForm, setFeedbackForm] = useState<FeedbackForm>({
    content: '',
    predictionId: undefined
  });
  
  // Snackbar state
  const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: '',
    severity: 'info'
  });
  
  // Statistics state
  const [statistics, setStatistics] = useState<UserStatistics>({
    totalPredictions: 0,
    fakePredictions: 0,
    realPredictions: 0,
    predictionAccuracy: 0,
    feedbackCount: 0
  });

  // Fetch user data
  const { data: user, isLoading: isUserLoading } = useQuery<User, Error>({
    queryKey: ['userProfile'],
    queryFn: async () => {
      const { data } = await api.get<ApiResponse<User>>('/profile');
      return data.data;
    }
  });

  // Fetch user predictions
  const { data: predictions = [], isLoading: isPredictionsLoading } = useQuery<Prediction[], Error>({
    queryKey: ['userPredictions'],
    queryFn: async () => {
      const { data } = await api.get<ApiResponse<Prediction[]>>('/my-predictions');
      return data.data;
    }
  });

  // Calculate statistics when predictions change
  React.useEffect(() => {
    if (predictions && predictions.length > 0) {
      const total = predictions.length;
      const fake = predictions.filter(pred => isFakePrediction(pred)).length;
      const real = total - fake;
      const accuracy = total > 0 ? Math.round((real / total) * 100) : 0;
      const feedbackCount = predictions.filter(p => p.feedback).length;
      
      setStatistics({
        totalPredictions: total,
        fakePredictions: fake,
        realPredictions: real,
        predictionAccuracy: accuracy,
        feedbackCount: feedbackCount,
        lastPredictionDate: predictions[0]?.created_at,
        mostCommonCategory: fake > real ? 'Fake' : 'Real'
      });
    }
  }, [predictions]);

  // Handle password change
  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setPasswordForm(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // Handle feedback change
  const handleFeedbackChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { value } = e.target;
    setFeedbackForm(prev => ({
      ...prev,
      content: value
    }));
  };

  // Toggle password visibility
  const handleClickShowPassword = (field: keyof typeof showPassword) => {
    setShowPassword(prev => ({
      ...prev,
      [field]: !prev[field]
    }));
  };

  // Toggle prediction expansion
  const handleTogglePrediction = (id: string) => {
    setExpandedPrediction(prev => prev === id ? null : id);
  };

  // Handle password form submission
  const handleSubmitPasswordChange = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      if (passwordForm.newPassword !== passwordForm.confirmPassword) {
        setSnackbar({
          open: true,
          message: 'Yeni şifreler eşleşmiyor!',
          severity: 'error'
        });
        return;
      }

      await api.post('/update-password', {
        old_password: passwordForm.oldPassword,
        new_password: passwordForm.newPassword
      });

      setSnackbar({
        open: true,
        message: 'Şifre başarıyla güncellendi!',
        severity: 'success'
      });
      
      setPasswordDialogOpen(false);
      setPasswordForm({
        oldPassword: '',
        newPassword: '',
        confirmPassword: ''
      });
    } catch (error: any) {
      setSnackbar({
        open: true,
        message: error.response?.data?.detail || 'Şifre güncellenirken bir hata oluştu!',
        severity: 'error'
      });
    }
  };

  // Handle feedback submission
  const handleSubmitFeedback = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!feedbackForm.predictionId || !feedbackForm.content.trim()) return;
    
    try {
      await api.post('/submit-feedback', {
        prediction_id: feedbackForm.predictionId,
        content: feedbackForm.content
      });

      // Invalidate predictions query to refetch with updated feedback
      await queryClient.invalidateQueries({ queryKey: ['userPredictions'] });
      
      setSnackbar({
        open: true,
        message: 'Geri bildiriminiz için teşekkürler!',
        severity: 'success'
      });
      
      setFeedbackDialogOpen(false);
      setFeedbackForm({ content: '', predictionId: undefined });
    } catch (error: any) {
      setSnackbar({
        open: true,
        message: error.response?.data?.detail || 'Geri bildirim gönderilirken bir hata oluştu!',
        severity: 'error'
      });
    }
  };

  // Handle logout
  const handleLogout = async () => {
    try {
      await api.post('/sign-out');
      // Clear all queries from the cache
      queryClient.clear();
      // Redirect to login
      navigate('/login');
    } catch (error) {
      setSnackbar({
        open: true,
        message: 'Çıkış yapılırken bir hata oluştu!',
        severity: 'error'
      });
    }
  };

  // Handle snackbar close
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  
  // State for dialogs
  const [passwordDialogOpen, setPasswordDialogOpen] = useState<boolean>(false);
  const [feedbackDialogOpen, setFeedbackDialogOpen] = useState<boolean>(false);
  const [expandedPrediction, setExpandedPrediction] = useState<string | null>(null);
  
  // Password visibility state
  const [showPassword, setShowPassword] = useState({
    old: false,
    new: false,
    confirm: false
  });
  
  // Form states
  const [passwordForm, setPasswordForm] = useState<PasswordForm>({
    oldPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  const [feedbackForm, setFeedbackForm] = useState<FeedbackForm>({
    content: '',
    predictionId: undefined
  });
  
  // Snackbar state
  const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: '',
    severity: 'info'
  });
  
  // Statistics state
  const [statistics, setStatistics] = useState<UserStatistics>({
    totalPredictions: 0,
    fakePredictions: 0,
    realPredictions: 0,
    predictionAccuracy: 0,
    feedbackCount: 0
  });
  
  // Form states
  const [passwordForm, setPasswordForm] = useState<PasswordForm>({
    oldPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  const [feedbackForm, setFeedbackForm] = useState<FeedbackForm>({
    content: '',
    predictionId: undefined
  });
  
  // Snackbar state
  const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: '',
    severity: 'info'
  });
  
  // Statistics state
  const [statistics, setStatistics] = useState<UserStatistics>({
    totalPredictions: 0,
    fakePredictions: 0,
    realPredictions: 0,
    predictionAccuracy: 0,
    feedbackCount: 0
  });
  
  // Fetch user data
  const { 
    data: user, 
    isLoading: isUserLoading,
    error: userError 
  } = useQuery<User, Error>({
    queryKey: ['userProfile'],
    queryFn: async () => {
      const { data } = await api.get<ApiResponse<User>>('/profile');
      return data.data;
    },
    retry: 1,
    staleTime: 1000 * 60 * 5 // 5 minutes
  });
  
  // Fetch predictions
  const { 
    data: predictions = [], 
    isLoading: isPredictionsLoading,
    error: predictionsError 
  } = useQuery<Prediction[], Error>({
    queryKey: ['userPredictions'],
    queryFn: async () => {
      const { data } = await api.get<ApiResponse<Prediction[]>>('/my-predictions');
      return data.data || [];
    },
    retry: 1,
    staleTime: 1000 * 60 * 5 // 5 minutes
  });
  
  // Update statistics when predictions change
  useEffect(() => {
    if (predictions && predictions.length > 0) {
      const fakePredictions = predictions.filter(isFakePrediction).length;
      const realPredictions = predictions.length - fakePredictions;
      const accuracy = Math.round((realPredictions / predictions.length) * 100) || 0;
      
      setStatistics({
        totalPredictions: predictions.length,
        fakePredictions,
        realPredictions,
        predictionAccuracy: accuracy,
        feedbackCount: predictions.filter(p => p.feedback).length,
        lastPredictionDate: predictions[0]?.created_at,
        mostCommonCategory: fakePredictions > realPredictions ? 'Fake' : 'Real'
      });
    } else {
      // Reset statistics if no predictions
      setStatistics({
        totalPredictions: 0,
        fakePredictions: 0,
        realPredictions: 0,
        predictionAccuracy: 0,
        feedbackCount: 0
      });
    }
  }, [predictions]);
  
  // Handle errors
  useEffect(() => {
    if (userError) {
      setSnackbar({
        open: true,
        message: 'Kullanıcı bilgileri yüklenirken hata oluştu.',
        severity: 'error'
      });
    }
    
    if (predictionsError) {
      setSnackbar({
        open: true,
        message: 'Tahmin geçmişi yüklenirken hata oluştu.',
        severity: 'error'
      });
    }
  }, [userError, predictionsError]);
  
  // Handle snackbar close
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };
  
  // Toggle password visibility
  const togglePasswordVisibility = (field: 'old' | 'new' | 'confirm') => {
    setShowPassword(prev => ({
      ...prev,
      [field]: !prev[field as keyof typeof prev]
    }));
  };
  
  // Toggle prediction expansion
  const togglePredictionExpanded = (predictionId: string) => {
    setExpandedPrediction(prev => 
      prev === predictionId ? null : predictionId
    );
  };
  
  // Handle form changes
  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setPasswordForm(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleFeedbackChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFeedbackForm(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Handle form submissions
  const handleSubmitPassword = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (passwordForm.newPassword !== passwordForm.confirmPassword) {
      setSnackbar({
        open: true,
        message: 'Yeni şifreler eşleşmiyor!',
        severity: 'error'
      });
      return;
    }
    
    try {
      await api.put('/update-password', {
        old_password: passwordForm.oldPassword,
        new_password: passwordForm.newPassword
      });
      
      setPasswordForm({
        oldPassword: '',
        newPassword: '',
        confirmPassword: ''
      });
      
      setPasswordDialogOpen(false);
      
      setSnackbar({
        open: true,
        message: 'Şifreniz başarıyla güncellendi.',
        severity: 'success'
      });
    } catch (error: any) {
      const message = error.response?.data?.detail || 'Şifre güncellenirken bir hata oluştu.';
      setSnackbar({
        open: true,
        message,
        severity: 'error'
      });
    }
  };
  
  const handleSubmitFeedback = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!feedbackForm.content.trim()) {
      setSnackbar({
        open: true,
        message: 'Lütfen geri bildirim içeriği giriniz.',
        severity: 'warning'
      });
      return;
    }
    
    try {
      await api.post('/submit-feedback', {
        content: feedbackForm.content,
        prediction_id: feedbackForm.predictionId
      });
      
      setFeedbackForm({
        content: '',
        predictionId: undefined
      });
      
      setFeedbackDialogOpen(false);
      
      setSnackbar({
        open: true,
        message: 'Geri bildiriminiz için teşekkür ederiz!',
        severity: 'success'
      });
      
      queryClient.invalidateQueries({ queryKey: ['userPredictions'] });
    } catch (error: any) {
      const message = error.response?.data?.detail || 'Geri bildirim gönderilirken bir hata oluştu.';
      setSnackbar({
        open: true,
        message,
        severity: 'error'
      });
    }
  };
  
  // Handle logout
  const handleLogout = async () => {
    try {
      await api.post('/sign-out');
      queryClient.clear();
      navigate('/sign-in');
    } catch (error) {
      setSnackbar({
        open: true,
        message: 'Çıkış yapılırken bir hata oluştu.',
        severity: 'error'
      });
    }
  };
  
  // Format date
  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('tr-TR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };
  
  // Check if prediction is fake
  const isFakePrediction = (prediction: Prediction): boolean => {
    try {
      if (!prediction.output_data) return false;
      
      const output = typeof prediction.output_data === 'string' 
        ? JSON.parse(prediction.output_data)
        : prediction.output_data;
      
      // Check for fake indicators
      if (output.is_fake !== undefined) return output.is_fake;
      if (output.result === '0' || output.result === 0) return true;
      if (output.prediction?.toLowerCase() === 'fake') return true;
      if (output.label?.toLowerCase() === 'fake') return true;
      
      return false;
    } catch (error) {
      console.error('Error checking if prediction is fake:', error);
      return false;
    }
  };
  
  // Render loading state
  if (isUserLoading) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4, display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '60vh' }}>
        <CircularProgress />
      </Container>
    );
  }
  
  // Render error state
  if (userError) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4 }}>
        <Alert severity="error">
          Kullanıcı bilgileri yüklenirken bir hata oluştu. Lütfen daha sonra tekrar deneyiniz.
        </Alert>
      </Container>
    );
  }
  
  // Main render
  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      {/* User Profile Section */}
      <Paper elevation={3} sx={{ p: 3, mb: 4 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <Box display="flex" alignItems="center">
            <Avatar 
              sx={{ 
                width: 80, 
                height: 80, 
                fontSize: '2rem',
                bgcolor: 'primary.main',
                mr: 3
              }}
            >
              {user?.full_name?.charAt(0).toUpperCase() || 'U'}
            </Avatar>
            <Box>
              <Typography variant="h4" component="h1" gutterBottom>
                {user?.full_name || 'Kullanıcı'}
              </Typography>
              <Typography variant="body1" color="text.secondary" gutterBottom>
                {user?.email}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Üyelik Tarihi: {user?.created_at ? formatDate(user.created_at) : 'Bilinmiyor'}
              </Typography>
            </Box>
          </Box>
          <Box>
            <Button 
              variant="outlined" 
              startIcon={<LockResetIcon />}
              onClick={() => setPasswordDialogOpen(true)}
              sx={{ mr: 1 }}
            >
              Şifre Değiştir
            </Button>
            <Button 
              variant="outlined" 
              startIcon={<FeedbackIcon />}
              onClick={() => setFeedbackDialogOpen(true)}
              sx={{ mr: 1 }}
            >
              Geri Bildirim Gönder
            </Button>
            <Button 
              variant="outlined" 
              startIcon={<HomeIcon />}
              onClick={() => navigate('/')}
              sx={{ mr: 1 }}
            >
              Ana Sayfa
            </Button>
            <Button 
              variant="outlined" 
              color="error" 
              startIcon={<LogoutIcon />}
              onClick={handleLogout}
            >
              Çıkış Yap
            </Button>
          </Box>
        </Box>
      </Paper>
      
      {/* Statistics Section */}
      <Grid container spacing={3} sx={{ mb: 4 }}>
        <Grid item xs={12} md={6} lg={3}>
          <StatCard 
            title="Toplam Tahmin"
            value={statistics.totalPredictions}
            icon={<ArticleIcon />}
            color="#1976d2"
          />
        </Grid>
        <Grid item xs={12} md={6} lg={3}>
          <StatCard 
            title="Sahte Haber"
            value={statistics.fakePredictions}
            icon={<WarningAmberIcon />}
            color="#d32f2f"
          />
        </Grid>
        <Grid item xs={12} md={6} lg={3}>
          <StatCard 
            title="Gerçek Haber"
            value={statistics.realPredictions}
            icon={<VerifiedIcon />}
            color="#2e7d32"
          />
        </Grid>
        <Grid item xs={12} md={6} lg={3}>
          <StatCard 
            title="Doğruluk Oranı"
            value={`%${statistics.predictionAccuracy}`}
            icon={<TimelineIcon />}
            color="#ed6c02"
          />
        </Grid>
      </Grid>
      
      {/* Predictions Section */}
      <Paper elevation={3} sx={{ p: 3 }}>
        <Typography variant="h5" component="h2" gutterBottom>
          <Box display="flex" alignItems="center">
            <AssignmentIcon sx={{ mr: 1 }} />
            Tahmin Geçmişi
          </Box>
        </Typography>
        
        {isPredictionsLoading ? (
          <Box display="flex" justifyContent="center" my={4}>
            <CircularProgress />
          </Box>
        ) : predictionsError ? (
          <Alert severity="error" sx={{ mb: 3 }}>
            Tahmin geçmişi yüklenirken bir hata oluştu.
          </Alert>
        ) : predictions.length === 0 ? (
          <Alert severity="info" sx={{ mb: 3 }}>
            Henüz tahmin geçmişiniz bulunmamaktadır.
          </Alert>
        ) : (
          <List>
            {predictions.map((prediction) => (
              <React.Fragment key={prediction.id}>
                <ListItemButton 
                  onClick={() => togglePredictionExpanded(prediction.id)}
                  sx={{ 
                    border: '1px solid', 
                    borderColor: 'divider', 
                    borderRadius: 1,
                    mb: 1,
                    '&:hover': {
                      backgroundColor: 'action.hover',
                    }
                  }}
                >
                  <ListItemText
                    primary={
                      <Box display="flex" justifyContent="space-between" alignItems="center">
                        <Typography variant="subtitle1" noWrap sx={{ flex: 1, mr: 2 }}>
                          {prediction.title || 'Başlıksız Tahmin'}
                        </Typography>
                        <Box display="flex" alignItems="center">
                          <Chip 
                            label={isFakePrediction(prediction) ? 'Sahte Haber' : 'Gerçek Haber'}
                            color={isFakePrediction(prediction) ? 'error' : 'success'}
                            size="small"
                            sx={{ mr: 1 }}
                          />
                          <Typography variant="caption" color="text.secondary" sx={{ mr: 2 }}>
                            {formatDate(prediction.created_at)}
                          </Typography>
                          {expandedPrediction === prediction.id ? <ExpandLess /> : <ExpandMore />}
                        </Box>
                      </Box>
                    }
                  />
                </ListItemButton>
                <Collapse in={expandedPrediction === prediction.id} timeout="auto" unmountOnExit>
                  <Box p={2} pl={4} borderLeft="4px solid" borderColor="divider">
                    <Typography variant="body2" color="text.secondary" paragraph>
                      <strong>Model:</strong> {prediction.model_name || 'Bilinmiyor'}<br />
                      <strong>Güven Skoru:</strong> {prediction.confidence ? `${Math.round(prediction.confidence * 100)}%` : 'Bilinmiyor'}<br />
                      <strong>Durum:</strong> {prediction.status || 'Tamamlandı'}
                    </Typography>
                    
                    <Typography variant="subtitle2" gutterBottom>
                      <strong>Çıktı:</strong>
                    </Typography>
                    <Box 
                      component="pre" 
                      sx={{ 
                        p: 2, 
                        bgcolor: 'background.paper', 
                        borderRadius: 1,
                        overflowX: 'auto',
                        fontSize: '0.8rem',
                        mb: 2
                      }}
                    >
                      {JSON.stringify(prediction.output_data, null, 2)}
                    </Box>
                    
                    {prediction.feedback ? (
                      <Alert severity="info" sx={{ mb: 2 }}>
                        <strong>Geri Bildiriminiz:</strong> {prediction.feedback}
                      </Alert>
                    ) : (
                      <Button
                        variant="outlined"
                        size="small"
                        startIcon={<RateReviewIcon />}
                        onClick={() => {
                          setFeedbackForm(prev => ({
                            ...prev,
                            predictionId: prediction.id
                          }));
                          setFeedbackDialogOpen(true);
                        }}
                      >
                        Geri Bildirim Gönder
                      </Button>
                    )}
                  </Box>
                </Collapse>
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>
      
      {/* Password Change Dialog */}
      <Dialog open={passwordDialogOpen} onClose={() => setPasswordDialogOpen(false)}>
        <DialogTitle>Şifre Değiştir</DialogTitle>
        <form onSubmit={handleSubmitPassword}>
          <DialogContent>
            <TextField
              margin="dense"
              label="Mevcut Şifre"
              type={showPassword.old ? 'text' : 'password'}
              fullWidth
              variant="outlined"
              name="oldPassword"
              value={passwordForm.oldPassword}
              onChange={handlePasswordChange}
              required
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      onClick={() => togglePasswordVisibility('old')}
                      edge="end"
                    >
                      {showPassword.old ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="dense"
              label="Yeni Şifre"
              type={showPassword.new ? 'text' : 'password'}
              fullWidth
              variant="outlined"
              name="newPassword"
              value={passwordForm.newPassword}
              onChange={handlePasswordChange}
              required
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      onClick={() => togglePasswordVisibility('new')}
                      edge="end"
                    >
                      {showPassword.new ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="dense"
              label="Yeni Şifre (Tekrar)"
              type={showPassword.confirm ? 'text' : 'password'}
              fullWidth
              variant="outlined"
              name="confirmPassword"
              value={passwordForm.confirmPassword}
              onChange={handlePasswordChange}
              required
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      onClick={() => togglePasswordVisibility('confirm')}
                      edge="end"
                    >
                      {showPassword.confirm ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setPasswordDialogOpen(false)}>İptal</Button>
            <Button type="submit" variant="contained" color="primary">
              Kaydet
            </Button>
          </DialogActions>
        </form>
      </Dialog>
      
      {/* Feedback Dialog */}
      <Dialog 
        open={feedbackDialogOpen} 
        onClose={() => setFeedbackDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>Geri Bildirim Gönder</DialogTitle>
        <form onSubmit={handleSubmitFeedback}>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              label="Geri Bildiriminiz"
              type="text"
              fullWidth
              variant="outlined"
              name="content"
              value={feedbackForm.content}
              onChange={handleFeedbackChange}
              multiline
              rows={4}
              required
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setFeedbackDialogOpen(false)}>İptal</Button>
            <Button type="submit" variant="contained" color="primary">
              Gönder
            </Button>
          </DialogActions>
        </form>
      </Dialog>
      
      {/* Snackbar */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert 
          onClose={handleCloseSnackbar} 
          severity={snackbar.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Container>
  );
};

// StatCard component
interface StatCardProps {
  title: string;
  value: string | number;
  icon: React.ReactNode;
  color: string;
}

const StatCard: React.FC<StatCardProps> = ({ title, value, icon, color }) => (
  <Card sx={{ 
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    textAlign: 'center',
    p: 2,
    borderLeft: `4px solid ${color}`,
    transition: 'transform 0.2s',
    '&:hover': {
      transform: 'translateY(-4px)',
      boxShadow: 3
    }
  }}>
    <Box sx={{ 
      width: 60, 
      height: 60, 
      borderRadius: '50%', 
      bgcolor: `${color}20`, 
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      mb: 2
    }}>
      {React.cloneElement(icon as React.ReactElement, { 
        sx: { 
          fontSize: 30, 
          color: color 
        } 
      })}
    </Box>
    <Typography variant="h5" component="div" sx={{ fontWeight: 'bold', mb: 1 }}>
      {value}
    </Typography>
    <Typography variant="body2" color="text.secondary">
      {title}
    </Typography>
  </Card>
);

export default Profile;

// Main component
export default function Profile() {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  
  // State for dialogs
  const [passwordDialogOpen, setPasswordDialogOpen] = useState<boolean>(false);
  const [feedbackDialogOpen, setFeedbackDialogOpen] = useState<boolean>(false);
  const [expandedPrediction, setExpandedPrediction] = useState<string | null>(null);
  
  // Password visibility state
  const [showPassword, setShowPassword] = useState({
    old: false,
    new: false,
    confirm: false
  });
  
  // Form states
  const [passwordForm, setPasswordForm] = useState<PasswordForm>({
    oldPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  const [feedbackForm, setFeedbackForm] = useState<FeedbackForm>({
    content: '',
    predictionId: undefined
  });
  
  // Snackbar state
  const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: '',
    severity: 'info'
  });
  
  // Statistics state
  const [statistics, setStatistics] = useState<UserStatistics>({
    totalPredictions: 0,
    fakePredictions: 0,
    realPredictions: 0,
    predictionAccuracy: 0,
    feedbackCount: 0
  });
  
  // Fetch user data
  const { data: user, isLoading: isUserLoading } = useQuery<User>({
    queryKey: ['userProfile'],
    queryFn: async () => {
      const { data } = await api.get<ApiResponse<User>>('/profile');
      return data.data;
    },
    retry: 1,
    staleTime: 1000 * 60 * 5 // 5 minutes
  });
      }
      
      // Handle object output (from direct API response)
      if (typeof prediction.output_data === 'object' && prediction.output_data !== null) {
        const output = Array.isArray(prediction.output_data) ? prediction.output_data[0] : prediction.output_data;
        return output?.label?.toLowerCase().includes('fake') || output?.result === '0';
      }
      
      return false;
    } catch (error) {
      console.error('Error determining prediction type:', error);
      return false;
    }
  };

  // Format date to a readable format
  const formatDate = (dateString?: string | Date) => {
    if (!dateString) return '';
    const date = typeof dateString === 'string' ? new Date(dateString) : dateString;
    if (isNaN(date.getTime())) return '';
    
    const options: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    };
    return date.toLocaleDateString('tr-TR', options);
  };

  // Handle logout
  const handleLogout = async () => {
    try {
      await logoutMutation.mutateAsync();
      localStorage.removeItem('token');
      navigate('/login');
    } catch (error) {
      setSnackbar({
        open: true,
        message: 'Çıkış yapılırken bir hata oluştu.',
        severity: 'error'
      });
    }
  };

  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };

  // Loading state
  if (isUserLoading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="60vh">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Dialog open={passwordDialogOpen} onClose={() => setPasswordDialogOpen(false)}>
        <DialogTitle>Şifre Değiştir</DialogTitle>
        <form onSubmit={handleSubmitPasswordChange}>
          <DialogContent>
            <TextField
              margin="normal"
              required
              fullWidth
              name="oldPassword"
              label="Mevcut Şifre"
              type={showPassword.old ? 'text' : 'password'}
              value={passwordForm.oldPassword}
              onChange={handlePasswordChange}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton onClick={() => togglePasswordVisibility('old')} edge="end">
                      {showPassword.old ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="newPassword"
              label="Yeni Şifre"
              type={showPassword.new ? 'text' : 'password'}
              value={passwordForm.newPassword}
              onChange={handlePasswordChange}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton onClick={() => togglePasswordVisibility('new')} edge="end">
                      {showPassword.new ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Yeni Şifre (Tekrar)"
              type={showPassword.confirm ? 'text' : 'password'}
              value={passwordForm.confirmPassword}
              onChange={handlePasswordChange}
              error={passwordForm.newPassword !== passwordForm.confirmPassword && passwordForm.confirmPassword !== ''}
              helperText={passwordForm.newPassword !== passwordForm.confirmPassword && passwordForm.confirmPassword !== '' ? 'Şifreler eşleşmiyor' : ''}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton onClick={() => togglePasswordVisibility('confirm')} edge="end">
                      {showPassword.confirm ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setPasswordDialogOpen(false)}>İptal</Button>
            <Button
              type="submit"
              variant="contained"
              color="primary"
              disabled={
                !passwordForm.oldPassword ||
                !passwordForm.newPassword ||
                !passwordForm.confirmPassword ||
                passwordForm.newPassword !== passwordForm.confirmPassword ||
                passwordChangeMutation.isPending
              }
            >
              {passwordChangeMutation.isPending ? 'Güncelleniyor...' : 'Güncelle'}
            </Button>
          </DialogActions>
        </form>
      </Dialog>

      <Dialog open={feedbackDialogOpen} onClose={() => setFeedbackDialogOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>Geri Bildirim Gönder</DialogTitle>
        <form onSubmit={handleSubmitFeedback}>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              name="content"
              label="Geri Bildiriminiz"
              type="text"
              fullWidth
              variant="outlined"
              multiline
              rows={6}
              value={feedbackForm.content}
              onChange={handleFeedbackChange}
              required
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setFeedbackDialogOpen(false)}>İptal</Button>
            <Button
              type="submit"
              variant="contained"
              color="primary"
              disabled={!feedbackForm.content.trim() || feedbackMutation.isPending}
            >
              {feedbackMutation.isPending ? 'Gönderiliyor...' : 'Gönder'}
            </Button>
          </DialogActions>
        </form>
      </Dialog>

      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert 
          onClose={() => setSnackbar(prev => ({ ...prev, open: false }))} 
          severity={snackbar.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>

      <Grid container spacing={4}>
        {/* Kullanıcı Profil Kartı */}
        <Grid item xs={12} md={4}>
          <Card>
            <CardContent sx={{ textAlign: 'center' }}>
              <Avatar
                sx={{
                  width: 120,
                  height: 120,
                  margin: '0 auto 16px',
                  bgcolor: 'primary.main',
                }}
              >
                <PersonIcon sx={{ fontSize: 60 }} />
              </Avatar>
              <Typography variant="h5" component="div" gutterBottom>
                {user?.full_name || 'Kullanıcı'}
              </Typography>
              <Typography color="textSecondary" gutterBottom>
                {user?.email}
              </Typography>
              <Typography variant="body2" color="textSecondary">
                Üyelik Tarihi: {new Date(user?.created_at).toLocaleDateString('tr-TR')}
              </Typography>
              <Box mt={3}>
                <Button
                  variant="outlined"
                  color="error"
                  startIcon={<LogoutIcon />}
                  onClick={() => logoutMutation.mutate()}
                  disabled={logoutMutation.isPending}
                >
                  Çıkış Yap
                </Button>
                <Button
                  variant="outlined"
                  color="primary"
                  startIcon={<LockResetIcon />}
                  onClick={() => setPasswordDialogOpen(true)}
                  sx={{ mr: 2, mb: 2 }}
                >
                  Şifre Değiştir
                </Button>
                <Button
                  variant="outlined"
                  color="primary"
                  startIcon={<FeedbackIcon />}
                  onClick={() => setFeedbackDialogOpen(true)}
                >
                  Geri Bildirim Gönder
                </Button>
            </Box>
          </CardContent>
        </Card>
      </Grid>

      {/* Tahminler Bölümü */}
      <Grid item xs={12} md={8}>
        <Card>
          <CardContent>
              <Typography variant="h6" gutterBottom>
                Tahmin Geçmişim
              </Typography>
              <Divider sx={{ mb: 2 }} />
              {isPredictionsLoading ? (
                <Box display="flex" justifyContent="center" my={4}>
                  <CircularProgress />
                </Box>
              ) : predictions && predictions.length > 0 ? (
                <List>
                  {predictions.map((prediction) => (
                    <Paper key={prediction.id} sx={{ mb: 2, p: 2 }}>
                      <ListItem 
                        button 
                        onClick={() => setExpandedPrediction(
                          expandedPrediction === prediction.id ? null : prediction.id
                        )}
                      >
                        <ListItemText
                          primary={`Model: ${prediction.model_name}`}
                          secondary={`Tarih: ${new Date(prediction.created_at).toLocaleString('tr-TR')}`}
                        />
                        <IconButton>
                          {expandedPrediction === prediction.id ? (
                            <ExpandLess />
                          ) : (
                            <ExpandMore />
                          )}
                        </IconButton>
                      </ListItem>
                      <Collapse in={expandedPrediction === prediction.id} timeout="auto" unmountOnExit>
                        <Box p={2}>
                          <Typography variant="body2" color="text.secondary" paragraph>
                            <strong>Makale:</strong>
                          </Typography>
                          <Paper variant="outlined" sx={{ p: 2, mb: 2, maxHeight: '200px', overflow: 'auto' }}>
                            <Typography variant="body2">
                              {prediction.input_data || 'Makale içeriği bulunamadı'}
                            </Typography>
                          </Paper>
                          <Box display="flex" alignItems="center" mb={2}>
                            <Typography variant="body2" color="text.secondary">
                              <strong>Durum:</strong>
                            </Typography>
                            <Box 
                              ml={1}
                              px={2}
                              py={0.5}
                              bgcolor={isFakePrediction(prediction) ? 'error.light' : 'success.light'}
                              color="white"
                              borderRadius={1}
                              display="inline-block"
                            >
                              {isFakePrediction(prediction) ? 'Sahte Makale' : 'Gerçek Makale'}
                            </Box>
                          </Box>
                          {prediction.confidence && (
                            <Typography variant="body2" color="text.secondary" paragraph>
                              <strong>Güven Skoru:</strong> %{(prediction.confidence * 100).toFixed(2)}
                            </Typography>
                          )}
                          {prediction.feedback ? (
                            <Box mt={2}>
                              <Typography variant="subtitle2">Geri Bildiriminiz:</Typography>
                              <Paper variant="outlined" sx={{ p: 2, mt: 1 }}>
                                <Typography variant="body2">
                                  {prediction.feedback.content}
                                </Typography>
                              </Paper>
                            </Box>
                          ) : (
                            <Button
                              size="small"
                              variant="outlined"
                              startIcon={<FeedbackIcon />}
                              onClick={() => {
                                setFeedbackForm({
                                  content: '',
                                  predictionId: prediction.id
                                });
                                setFeedbackDialogOpen(true);
                              }}
                              sx={{ mt: 1 }}
                            >
                              Geri Bildirim Ekle
                            </Button>
                          )}
                        </Box>
                      </Collapse>
                    </Paper>
                  ))}
                </List>
              ) : (
                <Typography variant="body1" color="textSecondary" textAlign="center" py={4}>
                  Henüz tahmin geçmişiniz bulunmamaktadır.
                </Typography>
              )}
            </CardContent>
          </Card>
        </Grid>
      </Grid>
      
      {/* Snackbar */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert 
          onClose={handleCloseSnackbar}
          severity={snackbar.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Container>
  );
};

export default Profile;